#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define INF 9999

int find(int parent[], int i) {
    if (parent[i] != i)
        parent[i] = find(parent, parent[i]); // Path compression
    return parent[i];
}


void union1(int parent[], int rank[], int i, int j) {
int root_i = find(parent, i);
    int root_j = find(parent, j);

    if (rank[root_i] < rank[root_j])
        parent[root_i] = root_j;
    else if (rank[root_i] > rank[root_j])
        parent[root_j] = root_i;
    else {
        parent[root_j] = root_i;
        rank[root_i]++;
	}
	// Write your code here...
}


void kruskalMST(int **cost, int V) {
int parent[V], rank[V];
    for (int i = 0; i < V; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    // Create edge list
    int edges[V * V][3];
    int edgeCount = 0;

    for (int i = 0; i < V; i++) {
        for (int j = i + 1; j < V; j++) {
            if (cost[i][j] != INF) {
                edges[edgeCount][0] = i;
                edges[edgeCount][1] = j;
                edges[edgeCount][2] = cost[i][j];
                edgeCount++;
            }
        }
    }

    // Sort edges by cost
    // Sort edges by cost, then by node indices for tie-breaking
for (int i = 0; i < edgeCount - 1; i++) {
    for (int j = i + 1; j < edgeCount; j++) {
        if (edges[i][2] > edges[j][2] ||
           (edges[i][2] == edges[j][2] && edges[i][0] > edges[j][0]) ||
           (edges[i][2] == edges[j][2] && edges[i][0] == edges[j][0] && edges[i][1] > edges[j][1])) {
            int temp0 = edges[i][0], temp1 = edges[i][1], temp2 = edges[i][2];
            edges[i][0] = edges[j][0]; edges[i][1] = edges[j][1]; edges[i][2] = edges[j][2];
            edges[j][0] = temp0; edges[j][1] = temp1; edges[j][2] = temp2;
        }
    }
}


    
    int mstWeight = 0;
    int e = 0;

    for (int i = 0; e < V - 1 && i < edgeCount; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int w = edges[i][2];

        if (find(parent, u) != find(parent, v)) {
            union1(parent, rank, u, v);
            printf("Edge %d:(%d, %d) cost:%d\n", e, u, v, w);
            mstWeight += w;
            e++;
        }
    }

    printf("Minimum cost= %d\n", mstWeight);
}




int main() {
    int V;
    printf("No of vertices: ");
    scanf("%d", &V);

    int **cost = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        cost[i] = (int *)malloc(V * sizeof(int));

    printf("Adjacency matrix:\n");
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            scanf("%d", &cost[i][j]);

    kruskalMST(cost, V);

    for (int i = 0; i < V; i++)
        free(cost[i]);
    free(cost);

    return 0;
}
